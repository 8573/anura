{
	shaders: {
		vertex: {
			simple_v: "
			uniform mat4 mvp_matrix;
			attribute vec4 a_position;
			void main() {
				gl_Position = mvp_matrix * a_position;
			}
			",
			
			iso_shader_v: "
				uniform mat4 mvp_matrix;
				attribute vec3 a_position;
				attribute vec2 a_tex_coord;
				varying vec2 tex_coord;

				void main()
				{
					gl_Position = mvp_matrix * vec4(a_position, 1.0);
					tex_coord = a_tex_coord;
				}
			",
			
			iso_shader_lighting_v: "
				#version 120

				// Input vertex data, different for all executions of this shader.
				attribute vec3 vertexPosition_modelspace;
				attribute vec2 a_tex_coord;

				// Output data ; will be interpolated for each fragment.
				varying vec2 UV;
				varying vec3 Position_worldspace;
				varying vec3 Normal_cameraspace;
				varying vec3 EyeDirection_cameraspace;
				varying vec3 LightDirection_cameraspace;

				// Values that stay constant for the whole mesh.
				uniform mat4 MVP;
				uniform mat4 V;
				uniform mat4 M;
				uniform vec3 LightPosition_worldspace;
				// for an arbitrary mesh this should be an attribute
				// for cubes this can be a uniform
				uniform vec3 vertexNormal_modelspace;

				void main(){

					// Output position of the vertex, in clip space : MVP * position
					gl_Position =  MVP * vec4(vertexPosition_modelspace,1);
					
					// Position of the vertex, in worldspace : M * position
					Position_worldspace = (M * vec4(vertexPosition_modelspace,1)).xyz;
					
					// Vector that goes from the vertex to the camera, in camera space.
					// In camera space, the camera is at the origin (0,0,0).
					vec3 vertexPosition_cameraspace = ( V * M * vec4(vertexPosition_modelspace,1)).xyz;
					EyeDirection_cameraspace = vec3(0,0,0) - vertexPosition_cameraspace;

					// Vector that goes from the vertex to the light, in camera space. M is ommited because it's identity.
					vec3 LightPosition_cameraspace = ( V * vec4(LightPosition_worldspace,1)).xyz;
					LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;
					
					// Normal of the the vertex, in camera space
					Normal_cameraspace = ( V * M * vec4(vertexNormal_modelspace,0)).xyz; // Only correct if ModelMatrix does not scale the model ! Use its inverse transpose if not.
					
					// UV of the vertex. No special space for this one.
					UV = a_tex_coord;
				}
			",
		},

		fragment: {
			simple_f: "
				void main() {
					gl_FragColor = vec4(0.0, 0.0, 0.0, 0.25);
				}
			",
			
			iso_shader_f: "
				varying vec2 tex_coord;
				uniform sampler2D u_tex0;

				void main()
				{
					vec4 texel = texture2D(u_tex0, tex_coord);
					if(texel.a < 0.1) {
						discard;
					}
					gl_FragColor = texel;
				}
			",
			
			iso_shader_lighting_f: "
				#version 120

				// Interpolated values from the vertex shaders
				varying vec2 UV;
				varying vec3 Position_worldspace;
				varying vec3 Normal_cameraspace;
				varying vec3 EyeDirection_cameraspace;
				varying vec3 LightDirection_cameraspace;

				// Values that stay constant for the whole mesh.
				uniform sampler2D u_tex0;
				//uniform mat4 MV;
				uniform vec3 LightPosition_worldspace;

				void main(){
					// Light emission properties
					// You probably want to put them as uniforms
					vec3 LightColor = vec3(1,1,1);
					float LightPower = 2000.0f;
					
					// Material properties
					vec3 MaterialDiffuseColor = texture2D( u_tex0, UV ).rgb;
					vec3 MaterialAmbientColor = vec3(0.1,0.1,0.1) * MaterialDiffuseColor;
					vec3 MaterialSpecularColor = vec3(0.3,0.3,0.3);

					// Distance to the light
					float distance = length( LightPosition_worldspace - Position_worldspace );

					// Normal of the computed fragment, in camera space
					vec3 n = normalize( Normal_cameraspace );
					// Direction of the light (from the fragment to the light)
					vec3 l = normalize( LightDirection_cameraspace );
					// Cosine of the angle between the normal and the light direction, 
					// clamped above 0
					//  - light is at the vertical of the triangle -> 1
					//  - light is perpendicular to the triangle -> 0
					//  - light is behind the triangle -> 0
					float cosTheta = clamp( dot( n,l ), 0,1 );
					
					// Eye vector (towards the camera)
					vec3 E = normalize(EyeDirection_cameraspace);
					// Direction in which the triangle reflects the light
					vec3 R = reflect(-l,n);
					// Cosine of the angle between the Eye vector and the Reflect vector,
					// clamped to 0
					//  - Looking into the reflection -> 1
					//  - Looking elsewhere -> < 1
					float cosAlpha = clamp( dot( E,R ), 0,1 );
					
					gl_FragColor.rgb = 
						// Ambient : simulates indirect lighting
						MaterialAmbientColor +
						// Diffuse : 'color' of the object
						MaterialDiffuseColor * LightColor * LightPower * cosTheta / (distance*distance) +
						// Specular : reflective highlight, like a mirror
						MaterialSpecularColor * LightColor * LightPower * pow(cosAlpha,5) / (distance*distance);
				}			
			",
		},
	},

	programs: [{
		name: "mycircle",
		vertex: "simple_v",
		fragment: "simple_f",
		attributes: {
			vertex: "a_position"
		},
		uniforms: {
			mvp_matrix: "mvp_matrix",
		}
	}, {
		name: "iso_shader",
		vertex: "iso_shader_v",
		fragment: "iso_shader_f",		
		attributes: {
			vertex: "a_position"
		},
		uniforms: {
			mvp_matrix: "mvp_matrix",
		}
	}, {
		name: "iso_shader_lighting",
		vertex: "iso_shader_lighting_v",
		fragment: "iso_shader_lighting_f",		
		attributes: {
			vertex: "vertexPosition_modelspace"
		},
		uniforms: {
			mvp_matrix: "MVP"
		}
	}],

	instances: [{
		name: "water_distort",
		new: true,
		vertex: "
		uniform mat4 u_anura_mvp_matrix;
		uniform float u_anura_cycle;
		uniform vec4 u_anura_sprite_area;
		uniform vec4 u_anura_draw_area;
		attribute vec4 a_anura_vertex;
		attribute vec2 a_anura_texcoord;
		varying vec2 v_texcoord;
		varying vec4 v_vertex;
		void main()
		{
			v_vertex = a_anura_vertex;
			gl_Position = u_anura_mvp_matrix * a_anura_vertex;
			v_texcoord = a_anura_texcoord;
		}
		",
		fragment: "
		uniform sampler2D u_anura_tex_map;
		uniform float u_intensity;
		uniform vec4 u_water_area[2];
		uniform float u_anura_cycle;
		uniform vec4 u_anura_draw_area;
		uniform vec4 u_anura_sprite_area;
		varying vec2 v_texcoord;
		varying vec4 v_vertex;
		void main()
		{
			vec2 texcoord = v_texcoord;
			for(int n = 0; n != 2; ++n) {
				if(u_water_area[n][0] >= u_water_area[n][2]) {
					break;
				}

				float left = max(u_anura_draw_area[0], u_water_area[n][0]);
				float top = max(u_anura_draw_area[1], u_water_area[n][1]);
				float right = min(u_anura_draw_area[2], u_water_area[n][2]);
				float bottom = min(u_anura_draw_area[3], u_water_area[n][3]);
				if(v_vertex[0] > left &&
				   v_vertex[1] > top &&
				   v_vertex[0] < right &&
				   v_vertex[1] < bottom) {
		
					float falloff_ratio = min(min(v_vertex[0] - left, right - v_vertex[0])/40.0, 1.0);
					
					texcoord[0] = texcoord[0] + falloff_ratio*sin((u_anura_draw_area[0] + v_vertex[0])*0.02 + u_anura_cycle/20.0)/300.0;
				}
			}
			gl_FragColor = texture2D(u_anura_tex_map, texcoord);
		}
		",

		draw: "[if(water_rects, set(uniform_commands.u_water_area, fold(water_rects[:2], a+b)),
							   set(uniform_commands.u_water_area, [0,0,0,0])),
							   ]

		  where water_rects = (
		
		[ [water.vars.zone_x1 - pos[0], water.vars.zone_y1 - pos[1], water.vars.zone_x2 - pos[0], water.vars.zone_y2 - pos[1]]
		  | water <- level.chars,
			water.type = 'water_controller',
			rects_intersect([water.vars.zone_x1, water.vars.zone_y1, water.vars.zone_x2, water.vars.zone_y2], camera_rect)
		] where camera_rect = [pos[0], pos[1], pos[0]+pos[2], pos[1]+pos[3]]
		  where pos = level.camera_position
		)
		"
	},
	
	{
		name: "iso_line",
		new: true,
		vertex: "
			uniform mat4 mvp_matrix;
			attribute vec3 a_position;
			void main()
			{
				gl_Position = mvp_matrix * vec4(a_position, 1.0);
			}
		",
		fragment: "
			uniform vec4 u_color;
			void main()
			{
				gl_FragColor = u_color;
			}
		",
		attributes: {
			vertex: "a_position"
		},
		uniforms: {
			color: "u_color",
			mvp_matrix: "mvp_matrix",
		}
	},
	
	{
		name: "iso_color_line",
		new: true,
		vertex: "
			uniform mat4 mvp_matrix;
			attribute vec3 a_position;
			attribute vec4 a_color;
			varying vec4 v_color;
			void main()
			{
				gl_Position = mvp_matrix * vec4(a_position, 1.0);
				v_color = a_color;
			}
		",
		fragment: "
			varying vec4 v_color;
			void main()
			{
				gl_FragColor = v_color;
			}
		",
		attributes: {
			vertex: "a_position",
			color: "a_color",
		},
		uniforms: {
			mvp_matrix: "mvp_matrix",
		}
	}, {
		name: "texture2d",
		new: true,
		vertex: "
			attribute vec4 a_position;
			attribute vec2 a_texcoord;			
			varying vec2 v_texcoord;
			uniform mat4 mvp_matrix;
			void main() {
				v_texcoord = a_texcoord;
				gl_Position = mvp_matrix * a_position;
			}",
		fragment: "
			uniform sampler2D u_tex_map;
			varying vec2 v_texcoord;
			void main() {
				gl_FragColor = texture2D(u_tex_map, v_texcoord);
			}",
		uniforms: {
			mvp_matrix: "mvp_matrix",
		},
		attributes: {
			vertex: "a_position",
			texcoord: "a_texcoord",
		},
	}, {
		name: "iso_diffuse",
		new: true,
		vertex: "
			attribute vec3 VertexPosition;
			uniform vec3 VertexNormal;	// assumes all vertices done with this shader have the same normal

			varying vec3 LightIntensity;
			uniform vec4 LightPosition;
			uniform vec3 Kd;  // Diffuse reflectivity
			uniform vec4 u_color;  // light source intensity (Ld)


			uniform mat4 ModelViewMatrix;
			uniform mat3 NormalMatrix;
			uniform mat4 ProjectionMatrix;
			uniform mat4 mvp_matrix;

			void main()
			{
				vec3 tnorm = normalize(NormalMatrix * VertexNormal);
				vec4 eyecoords = ModelViewMatrix * vec4(VertexPosition, 1.0);
				vec3 s = normalize(vec3(LightPosition - eyecoords));
				
				LightIntensity = vec3(u_color.r, u_color.g, u_color.b) * Kd * max(dot(s, tnorm), 0.0);
				gl_Position = mvp_matrix * vec4(VertexPosition, 1.0);
			}
		",
		fragment: "		
			varying vec3 LightIntensity;
			void main(void)
			{
				gl_FragColor = vec4(LightIntensity, 1.0);
			}
		",
		attributes: {
			vertex: "VertexPosition"
		},
		uniforms: {
			color: "u_color",
			mvp_matrix: "mvp_matrix",
		}
	}],

}
