/*
	Copyright (C) 2003-2013 by David White <davewx7@gmail.com>
	
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#if defined(USE_GLES2)
#include "formula_callable_definition.hpp"
#include "formula_function_registry.hpp"
#include "isoworld.hpp"
#include "user_voxel_object.hpp"
#include "voxel_object.hpp"
#include "voxel_object_functions.hpp"

void voxel_object_command_callable::set_expression(const game_logic::formula_expression* expr)
{
	expr_ = expr;
	expr_holder_.reset(expr);
}


void voxel_object_command_callable::run_command(voxel::world& lvl, voxel::voxel_object& obj) const
{
	if(expr_) {
		try {
			fatal_assert_scope scope;
			execute(lvl, obj);
		} catch(fatal_assert_failure_exception& e) {
			ASSERT_FATAL(e.msg << "\nERROR ENCOUNTERED WHILE RUNNING COMMAND GENERATED BY THIS EXPRESSION:\n" << expr_->debug_pinpoint_location());
		}
	} else {
		execute(lvl, obj);
	}
}

using namespace game_logic;

namespace {

const std::string FunctionModule = "voxel_object";

class spawn_voxel_command : public voxel_object_command_callable
{
public:
	spawn_voxel_command(voxel::voxel_object_ptr obj, variant instantiation_commands)
	  : obj_(obj), instantiation_commands_(instantiation_commands)
	{}
	virtual void execute(voxel::world& lvl, voxel::voxel_object& ob) const {

		lvl.add_object(obj_);

		obj_->execute_command(instantiation_commands_);
	}
private:
	voxel::voxel_object_ptr obj_;
	variant instantiation_commands_;
};

FUNCTION_DEF(spawn_voxel, 4, 6, "spawn_voxel(string type_id, decimal x, decimal y, decimal z, (optional) properties, (optional) list of commands cmd): will create a new object of type given by type_id with the given midpoint and facing. Immediately after creation the object will have any commands given by cmd executed on it. The child object will have the spawned event sent to it, and the parent object will have the child_spawned event sent to it.")

	formula::fail_if_static_context();

	const std::string type = EVAL_ARG(0).as_string();
	const float x = float(EVAL_ARG(1).as_decimal().as_float());
	const float y = float(EVAL_ARG(2).as_decimal().as_float());
	const float z = float(EVAL_ARG(3).as_decimal().as_float());

	variant arg4 = EVAL_ARG(4);

	voxel::voxel_object_ptr obj(new voxel::user_voxel_object(type, x, y, z));

	variant commands;
	spawn_voxel_command* cmd = (new spawn_voxel_command(obj, commands));
	cmd->set_expression(this);
	return variant(cmd);
FUNCTION_ARGS_DEF
	//ASSERT_LOG(false, "spawn() not supported in strict mode " << debug_pinpoint_location());
	ARG_TYPE("string")
	ARG_TYPE("decimal")
	ARG_TYPE("decimal")
	ARG_TYPE("decimal")
	ARG_TYPE("map")
	ARG_TYPE("commands")

	variant v;
	if(args()[0]->can_reduce_to_variant(v) && v.is_string()) {
		game_logic::formula_callable_definition_ptr type_def = custom_object_type::get_definition(v.as_string());
		const custom_object_callable* type = dynamic_cast<const custom_object_callable*>(type_def.get());
		ASSERT_LOG(type, "Illegal object type: " << v.as_string() << " " << debug_pinpoint_location());

		if(args().size() > 3) {
			variant_type_ptr map_type = args()[3]->query_variant_type();
			assert(map_type);

			const std::map<variant, variant_type_ptr>* props = map_type->is_specific_map();
			if(props) {
				foreach(int slot, type->slots_requiring_initialization()) {
					const std::string& prop_id = type->get_entry(slot)->id;
					ASSERT_LOG(props->count(variant(prop_id)), "Must initialize " << v.as_string() << "." << prop_id << " " << debug_pinpoint_location());
				}

				for(std::map<variant,variant_type_ptr>::const_iterator itor = props->begin(); itor != props->end(); ++itor) {
					const int slot = type->get_slot(itor->first.as_string());
					ASSERT_LOG(slot >= 0, "Unknown property " << v.as_string() << "." << itor->first.as_string() << " " << debug_pinpoint_location());

					const formula_callable_definition::entry& entry = *type->get_entry(slot);
					ASSERT_LOG(variant_types_compatible(entry.get_write_type(), itor->second), "Initializing property " << v.as_string() << "." << itor->first.as_string() << " with type " << itor->second->to_string() << " when " << entry.get_write_type()->to_string() << " is expected " << debug_pinpoint_location());
				}
			}
		}

		ASSERT_LOG(type->slots_requiring_initialization().empty() || args().size() > 3 && args()[3]->query_variant_type()->is_map_of().first, "Illegal spawn of " << v.as_string() << " property " << type->get_entry(type->slots_requiring_initialization()[0])->id << " requires initialization " << debug_pinpoint_location());
	}
RETURN_TYPE("commands")
END_FUNCTION_DEF(spawn_voxel)

}

#endif // USE_GLES2
